#+TITLE: Design and Implementation of the ABCL PATHNAME
* The ABCL PATHNAME Implementation

** Needs within ABCL

*** Pathname refactoring
"vaguely", I want to replace org.lisp.armedbear.Pathname with some
sort of abstraction that allows easier maintainence and understanding of the code.

#+begin_example
cl:logical-pathname  a cl:pathname
ext:url-pathname     a cl:pathname
ext:jar-pathname     a ext:url-pathname

#+end_example

We naively begin by attempting to outline reasons one can't replace with an interface.

**** constructors

These would be present for all =ext:url-pathname= 

#+BEGIN_SRC java
     new Pathname(namestring)
#+END_SRC

#+BEGIN_SRC java
    Pathname Pathname.create(namestring)
#+END_SRC

Use Builder or Factory?
<http://stackoverflow.com/questions/757743/what-is-the-difference-between-builder-design-pattern-and-factory-design-pattern>

Decide to use Builder so we can do stuff like.

#+begin_src java
      Pathname result = new PathnameBuilder()
        .setDirectory("/foo/bar/")
        .setName("baz")
        .setType("bat").build();
#+end_src

In any event, the Pathname constructors would be deprecated, and perhaps made =private=.


**** DONE Encapsulate fields with getter/setters
     CLOSED: [2020-06-19 Fri 17:42]

     - CLOSING NOTE [2020-06-19 Fri 17:42] \\
       Done in pathname-2-build.patch
**** TODO cache result of calling Namestring


** Description of Current Problems

As noted from <[[file:jar-pathnames.markdown][file:./jar-pathnames.markdown]]>.

Goals:

1.  All objects descending from =URL-PATHNAME= can roundtrip their namestring().

2.  Able to represent archives within archives abitrarily.

*** TODO Figure out what the class hierarchy 

Figure the hierarchy out abstractly, and then concretely in Java and Lisp.

Idea:  use =DEVICE= components to represent a pathname

#+NAME: Example of an archive in an archive
#+begin_example
jar:jar:file:~/work/abcl/dist/abcl.jar!/something.abcl!/__loader__._
#+end_example

#+NAME: 
#+begin_example
[jar:file:/tmp/foo.jar!/] 
  ^--has-device-- [jar:file:a/path/something.abcl!/] 
      ^--has-device-- [/__loader__._]
#+end_example

All the following pathnames should be valid:
#+begin_example
#p"file:/tmp/foo.jar" 
#p"jar:file:/tmp/foo.jar!/"
#p"jar:file:/tmp/foo.jar!/a/path/something.abcl"
#p"jar:file:/tmp/foo.jar!/a/path/something.abcl!/"
#p"jar:file:/tmp/foo.jar!/a/path/something.abcl!/__loader__._"
#+end_example


#+NAME: Parsing the namestring 
#+begin_src lisp
(pathname "jar:jar:file:~/work/abcl/dist/abcl.jar!/something.abcl!/__loader__._")
#+end_src

would create three pathnames:

#+begin_src lisp
  #1# #p(:device #2# :name "__loader__" :type "_")

  #2# #p(:device #3#: :name "something" :type "abcl"
                 :directory (:absolute))

  #3# #p(:device #p"/tmp/abcl/dist/abcl.jar" :name nil :type nil
         :directory nil :host nil :version nil)
#+end_src

| reference | namestring                                                         |
|-----------+--------------------------------------------------------------------|
| #1#       | jar:jar:file:/tmp/abcl/dist/abcl.jar!/something.abcl!/__loader__._ |
| #2#       | jar:jar:file:/tmp/abcl/dist/abcl.jar!/something.abcl!/             |
| #3#       | jar:file:/tmp/abcl/dist/abcl.jar!/                                 |

#3# has to have a device of nil in order to be a DOS drive letter under Windows.

Problems:

#3# is both a file and an archive source.  The namestring of #2#
encapsulates this, but a naked reference to #3# should be able to be
target of a DIRECTORY operation? 

No, there is a difference between:

| namestring                         | type         |
|------------------------------------+--------------|
| jar:file:/tmp/abcl/dist/abcl.jar!/ | jar-pathname |
| file:/tmp/abcl/dist/abcl.jar       |              |

So, any =JAR-PATHNAME= whose =:directory= is =nil= can be operated on
via =MERGE-PATHNAMES= to =DIRECTORY= if it names a valid file or directory.

#+begin_src 
(directory #p"jar:file:/tmp/abcl/dist/abcl.jar!/*.*")
#+end_src

**** TODO Does this use of =DIRECTORY= clash with current ways of distinguishing files and directories?

*** TODO Fix the representation in CL:PATHNAME of objects to reflect this hierarchy.

*** TODO Refactor the Java 

Use Builder pattern.  Don't use constructors, but rather
=Pathname.create()= and the five =Pathname.addDirectory()=
=Pathname.addDevice()= calls, which may chained.  

Misnamed: should be =Pathname.withDevice()=?


** Rename existing Java hierarchy?

Too destructive?!
| current      | new                                                        |
|--------------+------------------------------------------------------------|
| pathname-jar | pathname-archive pathname-zip-archive pathname-jar-archive |
| pathname-url | pathname-url                                               |

* Colophon
  #+begin_example
  Mark Evenson  
  Created: 2010
  Revised: <2020-06-19 Fri 18:09>
  #+end_example

